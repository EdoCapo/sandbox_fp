<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fede puzzona</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Sfondo cielo notturno profondo */
            background: linear-gradient(to bottom, #0f131f 0%, #1a1e2e 100%);
            cursor: crosshair;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <canvas id="dragonCanvas"></canvas>

    <script>
        const canvas = document.getElementById('dragonCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const mouse = { x: width / 2, y: height / 2 };
        let time = 0;
        
        // Variabili dinamiche per le nuove animazioni
        let blinkTimer = 0;
        let mouthOpen = 0; 

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // Configurazione Drago
        const numPunti = 60;
        const distanzaPunti = 8;
        const drago = [];
        for (let i = 0; i < numPunti; i++) {
            drago.push({ x: width / 2, y: height / 2 });
        }

        const coloreCorpo = "#d93838"; 
        const coloreSpine = "#ffcc00"; 
        const coloreAli = "#8c1c1c"; 
        const coloreCuore = "#ff2e2e";

        // Array per i sistemi particellari
        let cuoriActivi = [];
        let scintilleCoda = [];
        let nuvole = [];

        // Generazione iniziale delle nuvole
        for(let i = 0; i < 25; i++) {
            nuvole.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                r: Math.random() * 80 + 40,
                speed: Math.random() * 2 + 0.5,
                opacity: Math.random() * 0.04 + 0.01
            });
        }

        function getRaggio(i) {
            if (i < 6) return 8 + (i * 0.8); 
            if (i >= 6 && i < 18) return 14 + Math.sin((i - 6) / 12 * Math.PI) * 6; 
            return Math.max(2, 16 - ((i - 18) * 0.4)); 
        }

        function disegnaAla(flap) {
            ctx.save();
            ctx.rotate(flap - 0.2); 
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.quadraticCurveTo(40, 40, 20, 130); 
            ctx.quadraticCurveTo(-20, 100, -40, 75); 
            ctx.quadraticCurveTo(-20, 50, -25, 15); 
            ctx.closePath();
            
            ctx.fillStyle = coloreAli;
            ctx.fill();
            ctx.strokeStyle = coloreSpine;
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-5, 50, -40, 75);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-15, 60, -20, 110);
            ctx.stroke();
            ctx.restore();
        }

        function disegnaZampa(indice, lato) { 
            let dx = drago[indice-1].x - drago[indice+1].x;
            let dy = drago[indice-1].y - drago[indice+1].y;
            let angoloDirezione = Math.atan2(dy, dx);
            
            let angoloEsterno = angoloDirezione + (Math.PI / 2) * lato;
            let angoloPiega = angoloDirezione + (Math.PI * 0.75) * lato; 
            let raggioCorpo = getRaggio(indice);
            
            let spallaX = drago[indice].x + Math.cos(angoloEsterno) * (raggioCorpo - 4);
            let spallaY = drago[indice].y + Math.sin(angoloEsterno) * (raggioCorpo - 4);
            let articolazioneX = spallaX + Math.cos(angoloEsterno) * 18;
            let articolazioneY = spallaY + Math.sin(angoloEsterno) * 18;
            let piedeX = articolazioneX + Math.cos(angoloPiega) * 22;
            let piedeY = articolazioneY + Math.sin(angoloPiega) * 22;

            ctx.beginPath();
            ctx.moveTo(spallaX, spallaY);
            ctx.lineTo(articolazioneX, articolazioneY);
            ctx.lineTo(piedeX, piedeY);
            ctx.strokeStyle = coloreCorpo;
            ctx.lineWidth = 9;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.stroke();

            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            let dirArtiglioP = angoloPiega + (0.5 * lato);
            ctx.moveTo(piedeX + Math.cos(dirArtiglioP)*2, piedeY + Math.sin(dirArtiglioP)*2);
            ctx.lineTo(piedeX + Math.cos(dirArtiglioP)*8, piedeY + Math.sin(dirArtiglioP)*8);
            ctx.lineTo(piedeX + Math.cos(dirArtiglioP + 0.3)*3, piedeY + Math.sin(dirArtiglioP + 0.3)*3);
            ctx.fill();
            
            ctx.beginPath();
            let dirArtiglioC = angoloPiega;
            ctx.moveTo(piedeX + Math.cos(dirArtiglioC)*2, piedeY + Math.sin(dirArtiglioC)*2);
            ctx.lineTo(piedeX + Math.cos(dirArtiglioC)*9, piedeY + Math.sin(dirArtiglioC)*9);
            ctx.lineTo(piedeX + Math.cos(dirArtiglioC + 0.25)*4, piedeY + Math.sin(dirArtiglioC + 0.25)*4);
            ctx.fill();
        }

        function disegnaPercorsoCuore(x, y, dimensione) {
            ctx.beginPath();
            ctx.moveTo(x, y + dimensione / 4);
            ctx.bezierCurveTo(x, y, x - dimensione / 2, y, x - dimensione / 2, y + dimensione / 4);
            ctx.bezierCurveTo(x - dimensione / 2, y + dimensione / 2, x - dimensione / 4, y + dimensione * 0.75, x, y + dimensione);
            ctx.bezierCurveTo(x + dimensione / 4, y + dimensione * 0.75, x + dimensione / 2, y + dimensione / 2, x + dimensione / 2, y + dimensione / 4);
            ctx.bezierCurveTo(x + dimensione / 2, y, x, y, x, y + dimensione / 4);
            ctx.closePath();
        }

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouthOpen = 1.0; // Spalanca la bocca al massimo!

                // Angolo attuale della testa per sparare in avanti
                let dxT = drago[0].x - drago[2].x;
                let dyT = drago[0].y - drago[2].y;
                let angoloSparo = Math.atan2(dyT, dxT);

                for (let i = 0; i < 4; i++) {
                    let spread = (Math.random() - 0.5) * 0.8; 
                    cuoriActivi.push({
                        x: drago[0].x + Math.cos(angoloSparo)*20,
                        y: drago[0].y + Math.sin(angoloSparo)*20,
                        vx: Math.cos(angoloSparo + spread) * (15 + Math.random()*5),
                        vy: Math.sin(angoloSparo + spread) * (15 + Math.random()*5),
                        dimensione: 60 + Math.random() * 50,
                        alpha: 1,
                        lifespan: 120 + Math.random() * 40
                    });
                }
            }
        });

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // --- A. CALCOLO DINAMICA E DASH ---
            let targetX = mouse.x + Math.cos(time) * 30;
            let targetY = mouse.y + Math.sin(time * 0.8) * 30;
            
            // Calcola distanza per l'accelerazione (Dash)
            let distanzaMouse = Math.hypot(targetX - drago[0].x, targetY - drago[0].y);
            let speedMult = Math.min(distanzaMouse / 150, 2.5); // Fino a 2.5x di velocità
            speedMult = Math.max(speedMult, 0.8); // Minimo di velocità

            time += 0.05 * speedMult; // Le ali sbattono più forte se scatta veloce
            
            // Decadimento chiusura bocca
            if(mouthOpen > 0) mouthOpen -= 0.05; 
            if(mouthOpen < 0) mouthOpen = 0;

            // Timer battito palpebre
            if(Math.random() < 0.008) blinkTimer = 10;
            if(blinkTimer > 0) blinkTimer--;

            // --- B. SFONDO IN PARALLASSE (Nuvole) ---
            nuvole.forEach(n => {
                n.y += n.speed * (1 + speedMult * 0.5); // Scorrono più veloci se il drago scatta
                if(n.y - n.r > height) {
                    n.y = -n.r;
                    n.x = Math.random() * width;
                }
                ctx.beginPath();
                ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 220, 255, ${n.opacity})`;
                ctx.fill();
            });

            // --- C. MOVIMENTO DEL DRAGO ---
            drago[0].x += (targetX - drago[0].x) * (0.1 * speedMult);
            drago[0].y += (targetY - drago[0].y) * (0.1 * speedMult);

            for (let i = 1; i < numPunti; i++) {
                let dx = drago[i - 1].x - drago[i].x;
                let dy = drago[i - 1].y - drago[i].y;
                let distanza = Math.sqrt(dx * dx + dy * dy);

                if (distanza > distanzaPunti) {
                    drago[i].x = drago[i - 1].x - (dx / distanza) * distanzaPunti;
                    drago[i].y = drago[i - 1].y - (dy / distanza) * distanzaPunti;
                }
            }

            // --- D. SCINTILLE DALLA CODA ---
            if(Math.random() < 0.6) {
                scintilleCoda.push({
                    x: drago[numPunti-1].x, y: drago[numPunti-1].y,
                    vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2 + 1,
                    life: 1.0
                });
            }
            ctx.globalCompositeOperation = "screen"; // Effetto fusione luminosa
            for(let i = scintilleCoda.length - 1; i >= 0; i--) {
                let s = scintilleCoda[i];
                s.x += s.vx; s.y += s.vy; s.life -= 0.03;
                if(s.life <= 0) { scintilleCoda.splice(i, 1); continue; }
                ctx.beginPath();
                ctx.arc(s.x, s.y, 4 * s.life, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 150, 0, ${s.life})`;
                ctx.fill();
            }
            ctx.globalCompositeOperation = "source-over"; // Ripristina modalità normale

            // --- E. DISEGNO CORPO, ALI E ZAMPE ---
            ctx.fillStyle = coloreSpine;
            for (let i = 2; i < numPunti - 5; i += 3) {
                let dx = drago[i-1].x - drago[i+1].x;
                let dy = drago[i-1].y - drago[i+1].y;
                let angolo = Math.atan2(dy, dx);
                let perpendicolare = angolo + Math.PI / 2;
                
                let spessoreCorpo = getRaggio(i);
                let lunghezzaSpina = 15 - (i * 0.2);

                let spinaBaseX = drago[i].x + Math.cos(perpendicolare) * spessoreCorpo;
                let spinaBaseY = drago[i].y + Math.sin(perpendicolare) * spessoreCorpo;
                let spinaPuntaX = drago[i].x + Math.cos(perpendicolare) * (spessoreCorpo + lunghezzaSpina);
                let spinaPuntaY = drago[i].y + Math.sin(perpendicolare) * (spessoreCorpo + lunghezzaSpina);

                ctx.beginPath();
                ctx.moveTo(spinaBaseX, spinaBaseY);
                ctx.lineTo(spinaPuntaX, spinaPuntaY);
                ctx.lineTo(drago[i].x + Math.cos(perpendicolare + 0.5) * spessoreCorpo, drago[i].y + Math.sin(perpendicolare + 0.5) * spessoreCorpo);
                ctx.fill();
            }

            disegnaZampa(8, 1);  disegnaZampa(8, -1); 
            disegnaZampa(28, 1); disegnaZampa(28, -1);

            let indiceAli = 10; 
            let dxAli = drago[indiceAli - 1].x - drago[indiceAli + 1].x;
            let dyAli = drago[indiceAli - 1].y - drago[indiceAli + 1].y;
            let angoloAli = Math.atan2(dyAli, dxAli);
            
            ctx.save();
            ctx.translate(drago[indiceAli].x, drago[indiceAli].y);
            ctx.rotate(angoloAli);
            let flap = Math.sin(time * 6) * 0.6;
            disegnaAla(flap);
            ctx.scale(1, -1);
            disegnaAla(flap);
            ctx.restore();

            for (let i = numPunti - 1; i >= 0; i--) {
                ctx.save();
                ctx.translate(drago[i].x, drago[i].y);
                if (i > 0) {
                    let dxB = drago[i-1].x - drago[i].x;
                    let dyB = drago[i-1].y - drago[i].y;
                    ctx.rotate(Math.atan2(dyB, dxB));
                }
                
                let raggio = getRaggio(i);
                let gradienteCorpo = ctx.createRadialGradient(0, -raggio/2, 0, 0, -raggio/2, raggio * 1.5);
                gradienteCorpo.addColorStop(0, "#f25c5c"); 
                gradienteCorpo.addColorStop(1, coloreCorpo);   
                
                ctx.beginPath();
                ctx.ellipse(0, 0, raggio, raggio * 0.8, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradienteCorpo;
                ctx.fill();
                
                if (i % 2 === 0) {
                   ctx.beginPath();
                   ctx.ellipse(-raggio*0.2, 0, raggio*1.2, raggio*0.6, Math.PI / 8, Math.PI/2, Math.PI * 1.5);
                   ctx.fillStyle = 'rgba(0,0,0,0.15)'; 
                   ctx.fill();
                }
                ctx.restore();
            }

            // --- F. TESTA ARTICOLATA ---
            let angoloTesta = Math.atan2(drago[0].y - drago[2].y, drago[0].x - drago[2].x);
            
            ctx.save();
            ctx.translate(drago[0].x, drago[0].y);
            ctx.rotate(angoloTesta);

            // Mascella inferiore (si apre rotando verso il basso)
            ctx.save();
            ctx.rotate(mouthOpen * 0.6); 
            ctx.fillStyle = coloreCorpo;
            ctx.beginPath(); ctx.ellipse(10, 8, 20, 10, 0, 0, Math.PI*2); ctx.fill();
            // Interno bocca e gola
            ctx.fillStyle = "#4a0000";
            ctx.beginPath(); ctx.ellipse(12, 6, 16, 6, 0, 0, Math.PI*2); ctx.fill();
            ctx.restore();

            // Cranio Superiore (Sopra la mascella)
            ctx.fillStyle = coloreCorpo;
            ctx.beginPath();
            ctx.ellipse(6, -2, 24, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#660000";
            ctx.beginPath(); ctx.arc(24, -6, 2.5, 0, Math.PI * 2); ctx.fill(); // Narici
            ctx.beginPath(); ctx.arc(24, 2, 2.5, 0, Math.PI * 2); ctx.fill();

            // Occhi (Con logica di Blink)
            if(blinkTimer > 0) {
                // Occhi chiusi
                ctx.strokeStyle = "#8c1c1c";
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(6, -9); ctx.lineTo(14, -9); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(6, 5);  ctx.lineTo(14, 5);  ctx.stroke();
            } else {
                // Occhi aperti e cattivi
                ctx.fillStyle = "#ffcc00";
                ctx.beginPath(); ctx.ellipse(10, -10, 5, 2.5, Math.PI/4, 0, Math.PI * 2); ctx.fill(); 
                ctx.beginPath(); ctx.ellipse(10, 6, 5, 2.5, -Math.PI/4, 0, Math.PI * 2); ctx.fill();  
                ctx.fillStyle = "#000000";
                ctx.beginPath(); ctx.arc(11, -10, 1.8, 0, Math.PI * 2); ctx.fill(); 
                ctx.beginPath(); ctx.arc(11, 6, 1.8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "#ffffff";
                ctx.beginPath(); ctx.arc(12, -11, 1, 0, Math.PI * 2); ctx.fill(); 
                ctx.beginPath(); ctx.arc(12, 5, 1, 0, Math.PI * 2); ctx.fill();
            }

            // Corna
            ctx.strokeStyle = "#e6b800";
            ctx.lineWidth = 6;
            ctx.lineCap = "round";
            ctx.beginPath(); ctx.moveTo(-2, -16); ctx.quadraticCurveTo(-25, -35, -5, -50); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-2, 12); ctx.quadraticCurveTo(-25, 35, -5, 50); ctx.stroke();
            ctx.restore();

            // --- ILLUMINAZIONE DINAMICA ---
            if (mouthOpen > 0.1) {
                let glow = ctx.createRadialGradient(drago[0].x, drago[0].y, 0, drago[0].x, drago[0].y, 150);
                glow.addColorStop(0, `rgba(255, 50, 50, ${mouthOpen * 0.4})`);
                glow.addColorStop(1, 'rgba(255, 50, 50, 0)');
                ctx.globalCompositeOperation = "screen";
                ctx.fillStyle = glow;
                ctx.beginPath(); ctx.arc(drago[0].x, drago[0].y, 150, 0, Math.PI*2); ctx.fill();
                ctx.globalCompositeOperation = "source-over";
            }

            // --- G. CUORI "FEDE PUZZONA" ---
            ctx.save();
            ctx.shadowColor = 'rgba(255, 46, 46, 0.9)'; 
            ctx.shadowBlur = 20;
            for (let i = cuoriActivi.length - 1; i >= 0; i--) {
                let cuore = cuoriActivi[i];
                cuore.x += cuore.vx;
                cuore.y += cuore.vy;
                cuore.dimensione *= 1.015; 
                cuore.alpha *= 0.98; 
                cuore.vx *= 0.97; // Freno aerodinamico
                cuore.vy *= 0.97; 
                cuore.lifespan--;

                if (cuore.alpha <= 0 || cuore.lifespan <= 0) {
                    cuoriActivi.splice(i, 1);
                    continue;
                }

                ctx.globalAlpha = Math.min(cuore.alpha, 1);
                ctx.fillStyle = coloreCuore;
                disegnaPercorsoCuore(cuore.x, cuore.y - cuore.dimensione/2, cuore.dimensione);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 0; // Togliamo l'ombra dal testo per renderlo leggibile
                ctx.font = `bold ${cuore.dimensione/4.5}px Arial, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Fede puzzona', cuore.x, cuore.y + cuore.dimensione/5);
            }
            ctx.restore();

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
